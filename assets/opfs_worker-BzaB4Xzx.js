(function(){"use strict";async function M(){return navigator.storage.getDirectory()}async function y(i,e="",t=""){const s={};try{for await(const[r,c]of i.entries()){const a=e?`${e}/${r}`:r;if(c.kind==="file"){const g=await c.getFile();s[a]={kind:"file",handle:c,lastModified:g.lastModified,name:r,parentPath:e}}else c.kind==="directory"&&(s[a]={kind:"directory",handle:c,name:r,parentPath:e},Object.assign(s,await y(c,a,t)))}}catch(r){console.error(`Error listing entries in directory handle "${i.name}", path "${e||"/"}":`,r),self.postMessage({status:"warning",message:`ディレクトリ「${i.name}/${e||""}」の一覧取得中にエラー: ${r.message}`,targetDirName:t})}return s}async function u(i,e){let t=i;if(e===""||e===".")return i;const s=e.split("/").filter(r=>r!=="");for(const r of s)try{t=await t.getDirectoryHandle(r,{create:!0})}catch(c){throw console.error(`Error getting or creating directory handle for "${r}" within "${i.name}/${e}":`,c),c}return t}async function k(i,e,t,s){console.log(t);try{const r=await i.getFile(),a=await(await e.getFileHandle(t,{create:!0})).createWritable();return await a.write(r),await a.close(),{name:t,lastModified:s}}catch(r){throw console.error(`Error copying file "${t}" to OPFS directory "${e.name}":`,r),r}}async function $(i,e,t){try{t==="file"?await i.removeEntry(e):t==="directory"&&await i.removeEntry(e,{recursive:!0})}catch(s){if(s.name==="NotFoundError")console.warn(`Attempted to delete ${t} "${e}" from OPFS directory "${i.name}", but it was not found.`);else throw console.error(`Error deleting ${t} "${e}" from OPFS directory "${i.name}":`,s),s}}async function m(i,e,t){try{const s=await i.getDirectoryHandle("synclog",{create:!0}),r=`${e}.json`,a=await(await s.getFileHandle(r,{create:!0})).createWritable();await a.write(JSON.stringify(t)),await a.close()}catch(s){console.error(`Error writing sync log for ${e}:`,s)}}async function H(i,e){try{const t=await i.getDirectoryHandle("synclog",{create:!0}),s=`${e}.json`,a=await(await(await t.getFileHandle(s)).getFile()).text();return JSON.parse(a)}catch(t){return t.name==="NotFoundError"?{}:(console.error(`Error reading sync log for ${e}:`,t),{})}}async function L(i,e){var h;const t=(o,l)=>self.postMessage({status:o,message:l,targetDirName:e});t("progress","同期処理を開始...");const s=await M();let r;try{r=await s.getDirectoryHandle(e,{create:!0}),t("progress",`OPFS内のターゲットディレクトリ「/${e}」を準備`)}catch(o){console.error(`Failed to create/get target directory /${e} in OPFS:`,o),t("error",`OPFS内にターゲットディレクトリ「/${e}」を作成/取得できませんでした: ${o.message}`);return}t("progress",`同期元(${i.name})のリストを作成...`);const c=await y(i,"",e);t("progress",`同期先(OPFS /${e})のリストを作成...`);const a=await y(r,"",e),g=await H(s,e),w={};t("progress","比較とコピー/作成を開始...");for(const o in c){const l=c[o],n=a[o],p=l.parentPath,d=l.name;try{const f=await u(r,p);if(l.kind==="directory")(!n||n.kind!=="directory")&&(n&&n.kind!=="directory"&&(t("progress",`種類が不一致: OPFSから既存エントリ /${e}/${o} (${n.kind}) を削除中...`),await $(f,d,n.kind),delete g[o]),t("progress",`OPFSにディレクトリを作成: /${e}/${o}`),await f.getDirectoryHandle(d,{create:!0}));else if(l.kind==="file"){const E=l.lastModified,F=(h=g[o])==null?void 0:h.lastModified;if(!n||n.kind!=="file"||E>(F||0)){n&&n.kind!=="file"&&(t("progress",`種類が不一致: OPFSから既存エントリ /${e}/${o} (${n.kind}) を削除中...`),await $(f,d,n.kind),delete g[o]),t("progress",`OPFSにファイルをコピー中: /${e}/${o}`);const b=await k(l.handle,f,d,E);w[o]={lastModified:b.lastModified}}else n&&n.kind==="file"&&(w[o]={lastModified:F})}}catch(f){console.error(`Error processing source entry ${o} for target /${e}:`,f),t("error",`エントリ「/${e}/${o}」の処理中にエラー: ${f.message}`)}}t("progress",`OPFS /${e} 内の不要なファイルの削除を開始...`);const S=Object.keys(a).filter(o=>!c[o]).sort((o,l)=>l.length-o.length);for(const o of S){const l=a[o],n=l.parentPath,p=l.name;try{const d=n===""?r:await u(r,n);t("progress",`OPFSから削除中: /${e}/${o}`),await $(d,p,l.kind),delete g[o]}catch(d){console.error(`Error deleting OPFS entry /${e}/${o}:`,d),t("warning",`OPFSエントリ「/${e}/${o}」の削除中にエラー: ${d.message}`)}}await m(s,e,w),console.log(`Sync process for /${e} finished.`),t("completed","同期が完了しました。")}self.onmessage=async i=>{if(i.data&&i.data.type==="SYNC_REQUEST"){const{sourceDirectoryHandle:e,targetDirName:t}=i.data;if(!t||typeof t!="string"||t.trim()===""||t.includes("/")||t.includes("\\")||t==="."||t===".."){self.postMessage({status:"error",message:`OPFS内のターゲットディレクトリ名「${t||""}」が無効です。スラッシュやバックスラッシュ、'.' , '..' は含めず、空でない文字列を指定してください。`,targetDirName:t||"N/A"});return}const s=t.trim();if(!e||e.kind!=="directory"){self.postMessage({status:"error",message:"同期元のディレクトリハンドルが提供されていないか、無効です。",targetDirName:s});return}try{await L(e,s)}catch(r){console.error(`Critical error during sync worker execution for target /${s}:`,r),self.postMessage({status:"error",message:`同期中に致命的なエラーが発生しました: ${r.message}`,targetDirName:s})}}}})();
